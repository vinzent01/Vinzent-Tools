"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = exports.Convert = void 0;
const requester_1 = require("./parts/requester");
const config_1 = require("./parts/config");
var chainer_1 = require("./parts/chainer");
Object.defineProperty(exports, "Convert", { enumerable: true, get: function () { return chainer_1.Chainer; } });
const utils_1 = require("./parts/utils");
const axios_1 = __importDefault(require("axios"));
/**
 * Regular converter class definition.
 *
 * @export
 * @class Converter
 */
class Converter {
    /**
     * Creates an instance of Converter.
     * @param {(...ProviderReference[] | undefined[] | string[])} config
     * @memberof Converter
     */
    constructor(...config) {
        /**
         * Method to set the proxy configuration.
         * @param proxyConfiguration  The proxy configuration.
         */
        this.setProxyConfiguration = (proxyConfiguration) => {
            this.config.setClient(axios_1.default.create({ proxy: proxyConfiguration }));
        };
        /**
         * Conversion function (non chainable).
         *
         * @example
         * const converter = new Converter()
         * const converted = await converter.convert(15,"USD","EUR")
         * console.log(converted);
         *
         * @param {number} amount - amount to be converted
         * @param {string} from - base currency
         * @param {string} to - conversion currency
         * @param {any} rates - conversion rates, if they were pre-fetched
         * @returns {Promise<number>} - converted amount
         */
        this.convert = (amount_1, from_1, to_1, ...args_1) => __awaiter(this, [amount_1, from_1, to_1, ...args_1], void 0, function* (amount, from, to, rates = undefined) {
            // Returining conversion from provided rates
            if (typeof rates !== "undefined") {
                return this.convertRate(amount, to, rates);
            }
            //Fetching conversion rates from the active provider
            const [err, data] = yield (0, utils_1._to)(this.getRates(from, to, false));
            if (err) {
                throw err;
            }
            if (!data || Object.keys(data).length == 0) {
                throw new Error("No data returned for rate fetch.");
            }
            // Normalizing resulting rates data
            return this.convertRate(amount, to, data);
        });
        /**
         * Performs safe multiplication to get the result amount.
         * @param {number} amount - amount to be converted
         * @param {string} to - conversion currency
         * @param {any} rates - conversion rates, if they were pre-fetched
         * @returns
         */
        this.convertRate = (amount, to, rates = undefined) => {
            if (!rates[to]) {
                throw new Error(`No '${to}' present in rates: ${rates}`);
            }
            return amount * rates[to];
        };
        /**
         * Rate fetch function
         * @param {string} from - base currency
         * @param {string} to - conversion currency
         * @param {boolean} multiple - determines conversion mode
         * @returns
         */
        this.getRates = (from_2, to_2, ...args_2) => __awaiter(this, [from_2, to_2, ...args_2], void 0, function* (from, to, multiple = false) {
            // Getting the current active provider
            const provider = this.config.activeProvider();
            // Getting the client
            const client = this.config.getClient();
            // Fetching conversion rates from the active provider.
            const [err, data] = yield (0, utils_1._to)((0, requester_1.fetchRates)(client, provider, {
                FROM: from,
                TO: to,
                multiple: multiple
            }));
            // error handling:
            // if the error is not in the registered list of errors (is undefined), then throw.
            // if the error is in the list, but there are no backup providers, then throw.
            // if the error is in the list and there is a backup, log the error and continue.
            if (!err) {
                return provider.handler(data);
            }
            // unrecognized error
            if (!err.handled) {
                throw err.error;
            }
            // logging existing error
            console.error(err.error);
            if (this.config.providers.length <= 1) {
                throw err.error;
            }
            // removing current provider from active list
            this.config.remove(provider);
            // Retrying...
            return this.getRates(from, to, multiple);
        });
        this.config = new config_1.Config(...config);
        // Forwarding config adder function (with the alternative handle)
        this.add = this.config.add;
        this.addProvider = this.config.add;
        // Forwarding config multiple adder function (with the alternative handle)
        this.addMultiple = this.config.addMultiple;
        this.addMultipleProviders = this.config.addMultiple;
        this.remove = this.config.remove;
    }
    /**
     * Getters for active providers
     *
     * @readonly
     * @type {Provider[]}
     * @memberof Converter
     */
    get providers() {
        return this.config.providers;
    }
    get active() {
        return this.config.providers;
    }
}
exports.Converter = Converter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpREFBK0M7QUFFL0MsMkNBQTREO0FBQzVELDJDQUFxRDtBQUE1QyxrR0FBQSxPQUFPLE9BQVc7QUFDM0IseUNBQW9DO0FBQ3BDLGtEQUEwQjtBQVkxQjs7Ozs7R0FLRztBQUNILE1BQWEsU0FBUztJQVNwQjs7OztPQUlHO0lBQ0gsWUFBWSxHQUFHLE1BQW9EO1FBcUNuRTs7O1dBR0c7UUFDSCwwQkFBcUIsR0FBRyxDQUFDLGtCQUFzQyxFQUFFLEVBQUU7WUFDakUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsZUFBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDLENBQUM7UUFFRjs7Ozs7Ozs7Ozs7OztXQWFHO1FBQ0gsWUFBTyxHQUFHLG9DQUtTLEVBQUUseUVBSm5CLE1BQWMsRUFDZCxJQUFZLEVBQ1osRUFBVSxFQUNWLFFBQWEsU0FBUztZQUV0Qiw0Q0FBNEM7WUFDNUMsSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLEVBQUUsQ0FBQztnQkFDakMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDN0MsQ0FBQztZQUVELG9EQUFvRDtZQUNwRCxNQUFNLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLE1BQU0sSUFBQSxXQUFHLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFFOUQsSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDUixNQUFNLEdBQUcsQ0FBQztZQUNaLENBQUM7WUFFRCxJQUFJLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENB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